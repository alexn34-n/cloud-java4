 Ответить на вопросы (письменно):
1.Как организовать клиент-серверное взаимодействие?
В общих чертах последовательность действий описывается следующим образом:

   на стороне клиента:

   создание клиентского сокета;
   установка параметров сокета (IP-адрес и порт, к которым необходимо подключиться);
   установка соединения между сокетом и удаленной конечной точкой;
   отправка/получение информации;
   разрыв соединения и освобождение сокета.

   на стороне сервера:

   создание серверного сокета;
   установка параметров серверного сокета (IP-адрес и порт, на которые ожидаются подключения);
   перевод серверного сокета в режим отслеживания входящих соединений;
   при наличии входящего соединения: получить отдельный сокет для работы с этим конкретным соединением;
   отправка/получение информации;
   по окончании работы с клиентом: разрыв соединения и освобождение сокета, привязанного к этому клиенту;
   по окончании работы сервера: освобождение серверного сокета.


2.Как и в каком виде передавать файлы?

   Класс FileOutputStream предназначен для записи байтов в файл. Он является производным от класса OutputStream, поэтому наследует всю его функциональность.
   Через конструктор класса FileOutputStream задается файл, в который производится запись.
   Файл задается либо через строковый путь, либо через объект File. Второй параметр - append задает способ записи: eсли он равен true,
   то данные дозаписываются в конец файла, а при false - файл полностью перезаписывается.
   Для создания объекта FileOutputStream используется конструктор, принимающий в качестве параметра путь к файлу для записи.
   Если такого файла нет, то он автоматически создается при записи. Так как здесь записываем строку, то ее надо сначала перевести в массив байтов.
   С помощью метода write строка записывается в файл.
   Для автоматического закрытия файла и освобождения ресурса объект FileOutputStream создается с помощью конструктции try...catch.

   Для считывания данных из файла предназначен класс FileInputStream, который является наследником класса InputStream и поэтому реализует все его методы.
   Для создания объекта FileInputStream мы можем использовать ряд конструкторов. Наиболее используемая версия конструктора в качестве параметра
   принимает путь к считываемому файлу.
   Если файл не может быть открыт, например, по указанному пути такого файла не существует, то генерируется исключение FileNotFoundException.



3.Как пересылать большие файлы?

  * загрузить файл в куски  и отправить его таким образом.
  * использовать  поток BufferedReader.
  * использовать выражение  byte [] buffer=new byte[8192].


4.Как пересылать служебные команды?

  Связываем tcp сокет с потоком ввода-вывода и  персылаем строки. В каждой команда и соответствующие данные.
  После ввода строки в консоль клиента и нажатия enter строка проверяется не ввёл ли клиент кодовое слово для окончания общения дальше отправляется серверу,
  где он читает её и то же проверяет на наличие кодового слова выхода. Оба и клиент и сервер получив кодовое слово закрывают ресурсы после предварительных
  приготовлений и завершают свою работу.


5.Что хранить в базе данных?

  Набор данных с предопределенными связями между ними. Эти данные организованны в виде набора таблиц, состоящих из столбцов и строк.

6.Как передавать структуру каталогов/файлов?

  Класс File пакета java.io используется для управления информацией о файлах и каталогах. На уровне операционной системы файлы и каталоги имеют существенные отличия,
  но в Java они описываются одним классом File. Каталог в Java трактуется как обычный файл, но с дополнительным свойством — списком имен файлов, который можно просмотреть с помощью метода list.
  Кроме того, единственный способ перечислить все подкаталоги в Java - это использовать FilenameFilter в сочетании с File.list().

7 Какую библиотеку использовать для сетевого взаимодействия: java.io, java.nio, Netty?

  Лучше  использовать Netty-библиотеку.